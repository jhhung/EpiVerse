# %%
import os
#import cv2
import random
import numpy as np
from glob import glob
from PIL import Image, ImageOps
import matplotlib.pyplot as plt
from tqdm import tqdm
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib as mpl
import numpy as np
from datetime import datetime
import pickle
import argparse
from scipy import stats
from MIRNet import mirnet_model, get_dataset
# %%

def set_gpu_status(device):
    os.environ["XLA_FLAGS"]="--xla_gpu_cuda_data_dir=/usr/local/cuda"
    os.environ["CUDA_VISIBLE_DEVICES"] = device
    os.environ["CUDA_HOME"]="/usr/local/cuda"
    os.environ['NUMEXPR_NUM_THREADS']="32"
    gpus = tf.config.experimental.list_physical_devices('GPU')
    if gpus:
        try:
        # Currently, memory growth needs to be the same across GPUs
            for gpu in gpus:
                tf.config.experimental.set_memory_growth(gpu, True)
            logical_gpus = tf.config.experimental.list_logical_devices('GPU')
            print(len(gpus), "Physical GPUs,", len(logical_gpus), "Logical GPUs")
        except RuntimeError as e:
        # Memory growth must be set before GPUs have been initialized
            print(e)
            
def init_parser():
    """
    HiConformer + MIRNet parser
    """
    parser = argparse.ArgumentParser(description='MIRNet evaluation parser')
    parser.add_argument('--tissue', help='input evaluate tissue')
    parser.add_argument('--rootfolder', help='input evaluate tissue and output folder')
    parser.add_argument('--EVAL_CKPT', help='MIRNet model weights', type=str)
    parser.add_argument('--device', help='GPU device', type=str)
    args = parser.parse_args()
    return args

def convert_zscore2value(output_tensor, input_matrix):
    """
    Run prediction and convert output to zscore and original matrix
    """
    output_zscore = np.squeeze(output_tensor)
    output_original = output_zscore * np.std(input_matrix) + np.mean(input_matrix)
    output_original = np.clip(output_original, a_min=0, a_max=np.inf)
    return output_zscore, output_original

if __name__ == "__main__":
    IMAGE_SIZE = 200 ## The matrix generated by HiConformer2MIRNEt is 200*200
    BATCH_SIZE = 16 ## set batch size according to your GPU memory
    args = init_parser()
    TISSUE = args.tissue
    device = args.device
    set_gpu_status(device)
    print(f"Now processing {TISSUE}")
    RESULT_DIR_IMG = f"{args.rootfolder}/{TISSUE}/imputation_final/imgs"
    RESULT_DIR_NPY = f"{args.rootfolder}/{TISSUE}/imputation_final/npy"
    os.makedirs(RESULT_DIR_IMG, exist_ok=True)
    os.makedirs(RESULT_DIR_NPY, exist_ok=True)

    val_low_light_images = sorted(glob(f"{args.rootfolder}/{TISSUE}/HiConformer2MIRData/imputation/*.npy"))
    val_enhanced_images = sorted(glob(f"{args.rootfolder}/{TISSUE}/HiConformer2MIRData/ground_truth/*.npy"))
    print(f"Length of imputation Data is :{len(val_low_light_images)}")
    val_dataset = get_dataset(val_low_light_images, val_enhanced_images, batch_size=BATCH_SIZE)
    print(f"Build MIRNET model...")
    model = mirnet_model(num_rrg=2, num_mrb=2, channels=64)
    print(f"Loding MIRNET model weights from {args.EVAL_CKPT}")
    model.load_weights(args.EVAL_CKPT)
    model.summary()
    output_tensor = model.predict(val_dataset, 
                    batch_size=None, 
                    verbose=1, 
                    steps=None, 
                    max_queue_size=32,
                    workers=32)

    print(f"Output tensor shape is {output_tensor.shape}")
    
    # convert to numpy array for plot usage
    data_list = []
    for data in val_dataset:
        #print(data[0].shape)
        b, h, w, c = data[0].shape
        for i in range(b):        
            data_list.append((tf.squeeze(data[0][i]).numpy(), tf.squeeze(data[1][i]).numpy()))
            
    ## get file names
    files = [file_name.split("/")[-1].split(".")[0] for file_name in val_low_light_images]
    
    ## plot results and show some temporal results
    results = []
    for n in tqdm(range(len(data_list))):
        plt.figure(figsize=(16, 9))
        ## Ground truth
        plt.subplot(1, 3, 1)
        plt.title("ground truth")
        img_gt = np.load(val_enhanced_images[n])
        plt.imshow(img_gt, cmap="YlOrRd", vmax=10)
        ## HiConformer Prediction
        plt.subplot(1, 3, 2)
        plt.title("HiConformer Prediction")
        img_HiConformer = np.load(val_low_light_images[n])
        plt.imshow(img_HiConformer, cmap="YlOrRd", vmax=10)
        ## HiConformer + MIRNet Prediction
        plt.subplot(1, 3, 3)
        plt.title("HiConformer + MIRNet Restoration")
        img_final = output_tensor[n]
        #img_finalzscore, img_finalvalue = convert_zscore2value(img_final, img_HiConformer)
        plt.imshow(img_final, cmap="YlOrRd", vmax=10)
        #print(f"HiConformer + MIRNet Restoration Spearman-R: {stats.spearmanr(np.array(img_gt).flatten(), np.array(img_final).flatten())[0]}")
        #print(f"HiConformer Spearman-R: {stats.spearmanr(np.array(img_gt).flatten(), np.array(img_HiConformer).flatten())[0]}")
        chr, start, end = files[n].split("-") # [chr1, start, end.png] 
        plt.savefig(f"{RESULT_DIR_IMG}/{chr}_{start}_{int(start) + 1000000}.png")
        plt.close()
        np.save(f"{RESULT_DIR_NPY}/{chr}_{start}_{int(start) + 1000000}.npy", np.array(img_final))
